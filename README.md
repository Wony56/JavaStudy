# JavaStudy

## Java의 특징
- 객체지향언어이다.
- 함수적 프로그래밍을 지원한다.(람다식)
- 메모리를 자동으로 관리한다.(가비지 콜렉터(GC))
- 다양한 OS에서 실행되는 프로그램 개발이 가능하다.
- 멀티 스레드를 쉽게 구현할 수 있다.
- 동적 로딩을 지원한다.
- 다양한 오픈소스 라이브러리가 존재한다.

## Java의 기본타입
### 정수타입
- byte(1byte)
- short(2bytes)
- char(2bytes): 문자 리터럴이 저장됨.
- int(4bytes)
- long(8bytes)
### 실수타입
- float(4bytes)
- double(8bytes)
### 논리타입
- boolean(1byte): true/false가 저장됨.

### 타입변환
- 자동타입변환(promotion)
: 작은 크기의 타입을 큰 크기의 타입에 저장할 때 발생.
- 강제타입변환(casting)
: 큰 크기의 타입의 데이터를 쪼개서 작은 크기의 타입에 저장할 때 캐스팅 연산자를 사용하여 강제로 데이터를 저장.
  캐스팅 연산자에는 데이터를 쪼갤 단위의 타입을 기입한다.
  강제타입변환 후 데이터가 달라져서는 안된다.

## Java의 참조타입
 - 참조타입이란 객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입을 말함.
### JVM 메모리 영역
  #### 메소드 영역
  - 런타임 상수풀, 필드 데이터, 메소드 데이터, 메소드 코드, 생성자 코드 등으로 분류되며, JVM이 시작할 때 생성되고 모든 스레드가
  공유하는 영역.
  #### 스택 영역
  - 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당됨.
  - 메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행.
  - 프레임 내부에는 로컬 변수 스택이 있는데, 기본 타입 변수와 참조 타입 변수가 추가되거나 제거됨.
  #### 힙 영역
  - 객체와 배열이 생성되는 영역.
  - 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조함.
### String 타입
- ```String str = "abc";```는 힙 영역에 "abc"라는 String객체를 생성하고 스택 영역에 생성한 str변수로 참조한다는 뜻.
- String 객체는 문자열 리터럴로 생성하느냐 new 연산자로 생성하느냐에 따라 비교 연산자의 결과가 달라짐.
- 문자열만을 비교할 때는 String 객체의 equals()메소드를 사용.
### 배열 타입
- 배열도 **객체**이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조한다.
- 참조할 배열 객체가 없다면 배열 변수는 null값으로 초기화될 수 있다.
- 배열의 길이를 얻으려면 배열 객체의 length필드를 읽으면 된다.
  #### 다차원 배열
  - ```int[][] scores = new int[2][3];```는 힙 영역에 세 개의 배열 객체를 갱성한다.
    <br>=> 길이가 2인 int 배열 객채 1개와 길이가 3인 int 배열 객체 2개
    <br>=> 길이가 2인 배열 객체가 길이가 3인 배열 객체 2개를 참조한다.
    
## 클래스
### 객체 지향 프로그래밍(OOP)
  #### 객체 지향 프로그래밍의 특징
  1. 캡슐화
  - 캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다.
  - 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 **접근 제한자**를 사용한다.
  2. 상속
  3. 다형성
  - 다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
  - 부모 클래스 또는 인터페이스의 타입 변환을 허용하는데 ```부모 타입에는 모든 자식 객체가 대입될 수 있고,```
    ```인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.```

### 객체와 클래스
- 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
  => 클래스로부터 객체를 만드는 과정을 **인스턴스화**라고 한다.
  #### 클래스의 두 가지 용도
  1. 라이브러리(API) 클래스: 다른 클래스에서 이용할 목적으로 설계됨.
  2. 실행 클래스: main() 메소드를 제공.

### 생성자
  #### 생성자 오버로딩(Overloading)
  생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.
  ```java
  public class Car{
    Car() { ... }
    Car(String model) {...}
    Car(String model, String color) {...}
    Car(String model, String color, int speed) {...}
  }
  ```
  #### 다른 생성자 호출
  생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다. 이런 반복된 코드를 줄이기 위해
  중복된 코드를 가지는 다른 생성자를 호출하면 되는데 그때 사용하는 것이 바로 <b>this()</b>를 사용하는 것이다.
  <b>this()</b>는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.

### 정적 멤버(static)
- 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메서드이다.
- 필드와 메소드 선언 시 static키워드를 붙인다.
- 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.
- 정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스 별로 관리된다.
  #### 정적 메소드와 블록 선언 시 주의할 점
  - 정적 메소드와 정적 블록을 선언할 때 주의할 점은 객체가 없어도 된다는 실행되는 특징 때문에, 이들 내부에 인스턴스 필드나 인스턴스 메소드를
    사용할 수 없다.
  - this 키워드도 사용 불가능하다.
  - 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.
  ```java
  public class ClassName{
    int field1;
    
    void method1() {...}
    static void Method2() {
      ClassName obj = new ClassName();
      obj.field1 = 10;
      obj.method1();
    }
  }
  ```
  #### 싱글톤(Singleton)
  - 단 하나의 객체만을 생성하는 것을 싱글톤이라고 한다. 싱글톤을 만들기 위해서는 클래스 외부에서 new연산자로 생성자를 호출할 수 없도록 막아야 한다.
  <br>=> 생성자 앞에 private 접근 제한자를 붙여주면 된다.
  <br>=> 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해 준다.
  ```java
  public class 클래스{
    //정적 필드
    private static 클래스 singleton = new 클래스();

    //생성자
    private 클래스() {...}

    //정적 메소드
    static 클래스 getInstance(){
      return singleton;
    }
  }
  ```

### final필드와 상수
#### final필드
- final필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 것이다.
- final필드의 초기값을 줄 수 있는 방법은 딱 두 가지 밖에 없다.
  - 필드 선언 시에 준다.
  - 생성자에서 준다.
- 초기화되지 않은 final필드를 그대로 남겨두면 컴파일 에러가 발생한다.
#### 상수(static final)
- 일반적으로 불변의 값을 상수라고 부른다.
- final 필드를 상수라고 부르지는 않는다. 
  <br>=> 불변의 값은 객체마다 저장할 필요가 없는 <u>공용성</u>을 띠고 있으며, 여러 가지 값으로 초기화될 수 없기 때문이다.
  <br>=> final필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없다.
  <br>=> 상수는 static이면서 final이어야 한다.
- static final필드는 객체마다 저장되지 않고, 클래스에만 포함되며 한 번 초기값이 저장되면 변경할 수 없다.

### 접근 제한자
|접근 제한자|적용 대상|접근할 수 없는 클래스|
|-----|-------------|-------------------|
|public|클래스, 필드, 생성자, 메소드|없음|
|protected|필드, 생성자, 메소드|자식 클래스가 아닌 다른 패키지에 소속된 클래스|
|default|클래스, 필드, 생성자, 메소드|다른 패키지에 소속된 클래스|
|private|필드, 생성자, 메소드|모든 외부 클래스|

## 상속
### 강제 타입 변환(Casting)
- 부모 타입을 자식 타입으로 변환하는 것을 말한다.
- 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때에만 강제 타입 변환을 사용할 수 있다.
```
자식클래스 변수 = (자식클래스) 부모클래스타입;
```
```java
class Parent{
  String field1;
  void method1() { ... }
  void method2() { ... }
}

class Child extends Parent{
  String field2;
  void method3() { ... }
}

class ChildExample{
  public static void main(String[] args){
    Parent parent = new Child();
    parent.field2 = "yyy"; (불가능)
    parent.method3(); (불가능)
    
    Child child = (Child) parent;
    child.field2 = "yyy"; (가능)
    child.method3(); (가능)
   }
 }
```

### 추상 클래스
- 추상(abstract)은 실체 간에 공통되는 특성을 추출한 것을 말한다.
- 객체를 직접 생성할 수 있는 클래스를 <b>실체 클래스</b>라고 한다.
  이 클래스들의 공통적인 특성을 추출해서 선언한 클래스를 <b>추상 클래스</b>라고 한다.
  (추상 클래스는 new연산자를 사용해서 인스턴스를 생성시키지 못한다.)
  #### 추상 클래스의 용도
  1. 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적
  2. 실체 클래스를 작성할 때 시간을 절약
